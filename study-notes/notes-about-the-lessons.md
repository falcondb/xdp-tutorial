# Notes about the XDP tutorial
[XDP tutorial](https://github.com/xdp-project/xdp-tutorial)
## Lesson basic
### Lesson basic01
```
// Read the bpf object file and program fd with the given file name
bpf_prog_load() ==> bpf_prog_load_xattr() ==> bpf_object__open_xattr ==> __bpf_object__open ==> bpf_object__new // create a new bpf_object and fit it in

xdp_link_attach ==> bpf_set_link_xdp_fd (tools/lib/bpf/netlink.c)) ==> libbpf_netlink_open (in nlmsghdr, RTM_SETLINK ifinfomsg AF_UNSPEC, if_index, send() the nlmsghdr ifinfomsg nlattr with xdp) ;


```

### Lesson basic02

```
__load_bpf_and_xdp_attach ==> __load_bpf_object_file; bpf_object__find_program_by_title; bpf_program__fd; xdp_link_attach

```
### Lesson basic03
Note about the userspace stats program handles map-reloading.
> when userspace reads the map by syscall, it checks if the id in the bpf_map_info is different from the one previously read from kernel. If changed, use the new fd to read the map.

### Lesson basic04
Note about reusing an existing map when reloading an ELF with map definition inside (keep the existing map with the same path and settings and only reload the BPF program):
> * tools/lib/bpf/bpf.c provides a wrapper function for bpf syscall with BPF_OBJ_GET, which get the fd of the pinned map from kernel.
> * tools/lib/bpf/bpf_object__reuse_map.c:bpf_object__reuse_map() first tries to get the fd of the specified pinned map (using the path) by querying kernel, and check the compatibility. Then calls bpf_map__reuse_fd() that makes a syscall with BPF_OBJ_GET_INFO_BY_FD to get bpf_map_info. Open a new fd, and dup the fd of the existing map to the new fd, finally, sets the bpf_map_info of the existing map from kernel to the bpf_map loaded from ELF file.

## Lesson packet
### Lesson packet01

* The XDP is only attached to the ingress path, not the egress path.
* Seems sizeof(a struct XXX pointer) != sizeof(struct XXX). It should be same in regular c application, not sure about Clang/LLVM and BPF
* in bpf_endian.h, htons, htonl, ntohs, ntohl, remember the endian issue. Refer to [BPF Portability and CO-RE](https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html)
* IP package type definition is in if_ether.h, since the IP type is in the layer 2 frame
* IP4 layer definition in in.h; IP6 layer definition in in6.h
* icmp.h and icmpv6.h

When change the build toolchain and see "llc: error: expected top-level entity", the toolchain is mess up, reinstall them.
* The Vlan header [TPID 2 bytes, TCI 2 bytes] is added between source MAC and ethernet type. So, define
```
struct vlan_hdr {
	__be16	h_vlan_TCI;
	__be16	h_vlan_encapsulated_proto;
};
```
and then set the vlan_hdr pointer to the offset sizeof(ethernet header), the ethhdr.h_proto is the vlan TPID, and the TCI is the next 2 bytes. The encapsulated ethernet type will be at h_vlan_encapsulated_proto

### Lesson packet02
* The checksum in UDP is optional for IPV4, but mandatory for IPV6. Need to fix the checksum in IPV6.
* The TCI (Tag control information) in 802.1q (vlan) header contains 3 bits priority level and 1 bit congestion collection,
the rest 12 bits are for vid. The sample code doesn't explicitly separate them.
* Be careful with overflow, and remember calling `bpf_htons()` to the header.

#### Summary of packet02 exercise
* bpf_xdp_adjust_head/tail to extend/shrink the memory for the network package stack.
* The checksum in UDP is optional for IPV4! It is mandatory for TCP and IPv6.

### Lesson packet03
* when loading package03 kernel code, ulimit -l ==> unlimited (max locked memory). [Discussion](https://github.com/xdp-project/xdp-tutorial/issues/55)
* bpf_redirect()'s implementation is generated by BPF_CALL_2(bpf_redirect, u32, ifindex, u64, flags), see filter.h
* __builtin_memcpy() seems causes memory issue, see the [opened bug report](https://github.com/xdp-project/xdp-tutorial/issues/86)
* strtoul, strtoull, strtouq - convert a string to an unsigned long integer
* The error message I hit `WARN: Failed to update bpf map file: err(7):Argument list too long` is misleading, it turns out it is due to adding new element in a map whose max_entries is 1.
	* `Argument list too long` is the message for error code `E2BIG in uapi/asm-generic/errno-base.h`.
	* Looks like the `E2BIG` was from `alloc_htab_elem() in kernel/bpf/hashtab.c`

### Lesson packet04
* `bpf_fib_lookup` returns the src & dst MAC and the ifindex of the routing request (src & dst IPs etc. are given to `bpf_fib_lookup`).
* remember to decrease TTL
* Didn't figure out how to include AF_XXX macros, they are defined in linux/socket.h, but it is not included in the compiling, don't know why :(.
TODO: is it possible to implement the same routing by configure routing table??

#### Summary of packet03 exercise

* In lesson #1, the trick of echo ICMP request is: 1 ) swapping IP and Mac addresses and changing the ICMP type to ECHO_REPLY; 2) recalculating the checksum of ICMP package; 3) delivering the package back to the same dev.
* In lesson #2, two namespaces and their veth pairs are set up. The challenge is to enable ICMP between them. The trick played here is hard-coding the redirect ifindex and src & dst MAC address, adding the hard-coded MAC to the ICMP request package.
So, the receiver will receive it (XDP_PASS), but don't know how to reply to it.
* In lesson #3, a map is used to configure the src and dst MAC from userland.
* In lession #4, `bpf_fib_lookup` is called to get the src & dst MAC by the src & dst IPs.

The calculation of checksum in network protocols, and the re-calculation by using the delta in the package.

## Lesson tracing
### Lesson tracing01
* In the kernel side, at the tracing point, update the event count in a BPF map
* In the user side, load all the objects, like BPF progs and maps in the object file. Get the fd of the BPF prog attached to trace point. Read the id in ftrace/event/XXX/id, call `sys_perf_event_open` to open the perf event for the tracepoint and the call returns a fd of the perf event. `ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, bpf_fd)` to attach the BPF code to the trace point, finally, enable the perf event by `ioctl(event_fd, PERF_EVENT_IOC_ENABLE, 0)`.
* When I tried to attach a BPF program to the XDP tracepoint in a different net namespace `ip netns exec XXX bash`, an error saying `ERR: can't get program section`, which doesn't tell us the root cause. By debugging the loader code in the net namespace, I found the problem is the ftrace file system is not mounted. What a misleading error message.
